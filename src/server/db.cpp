/**********************************************************************
 * Copyright 2013 Georg Rudoy <0xd34df00d@gmail.com>
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **********************************************************************/

#include "db.h"
#include <unordered_set>
#include <mongo/client/dbclient.h>
#include "itemmongo.h"

namespace Laretz
{
	DBError::DBError (const std::string& reason)
	: runtime_error (reason)
	{
	}

	DBError::~DBError () noexcept
	{
	}

	namespace
	{
		void SetField (Item& item, const std::string& name, const mongo::BSONElement& elem)
		{
			Field_t field;
			switch (elem.type ())
			{
			case mongo::BSONType::NumberDouble:
				field = elem.Double ();
				break;
			case mongo::BSONType::NumberInt:
				field = static_cast<int64_t> (elem.Int ());
				break;
			case mongo::BSONType::String:
				field = elem.String ();
				break;
			case mongo::BSONType::Array:
			{
				const auto& arr = elem.Array ();
				std::vector<std::string> strings;
				for (const auto& elem : arr)
				{
					if (elem.type () != mongo::BSONType::String)
						continue;
					strings.push_back (elem.String ());
				}
				field = strings;
				break;
			}
			case mongo::BSONType::BinData:
			{
				int length = 0;
				const char *data = elem.binData (length);
				std::vector<char> vec;
				vec.reserve (length);
				std::copy (data, data + length, std::back_inserter (vec));
				field = vec;
			}
			default:
			{
				const auto& numStr = boost::lexical_cast<std::string> (elem.type ());
				throw std::runtime_error ("unknown field data type" + numStr);
			}
			}

			item [name] = field;
		}
	}

	DB::DB (const std::string& m_dbName)
	: m_dbPrefix ("user_" + m_dbName + '.')
	, m_svcPrefix ("service_" + m_dbName + '.')
	, m_conn (new mongo::DBClientConnection)
	{
		m_conn->connect ("localhost");
	}

	std::vector<Item> DB::enumerateItems (uint64_t after, const std::string& parent) const
	{
		std::vector<Item> result;

		if (!parent.empty ())
		{
			if (!getParentId (parent))
				throw UnknownParentError ("unknown parent for `" + parent + "`");
			drainParent (result, after, parent);
		}
		else
		{
			auto idCursor = m_conn->query (m_svcPrefix + "id2parent");
			std::unordered_set<std::string> knownParents;
			while (idCursor->more ());
				knownParents.insert (idCursor->next () ["parentId"].String ());

			for (const auto& parent : knownParents)
				drainParent (result, after, parent);
		}
		return result;
	}

	boost::optional<Item> DB::loadItem (const std::string& id)
	{
		const auto& parentId = getParentId (id);
		if (!parentId)
			return {};

		auto cursor = m_conn->query (getNamespace (*parentId), QUERY ("id" << id));
		if (!cursor->more ())
			return {};

		const auto& obj = cursor->next ();
		Item item
		{
			id,
			*parentId,
			static_cast<uint64_t> (obj ["seq"].Long ()),
			static_cast<uint64_t> (obj ["childrenSeq"].Long ())
		};

		std::set<std::string> fieldNames;
		obj.getFieldNames (fieldNames);
		for (auto knownField : { "id", "parentId", "seq", "childrenSeq" })
			fieldNames.erase (knownField);

		for (const auto& fieldName : fieldNames)
			SetField (item, fieldName, obj [fieldName]);

		return item;
	}

	std::vector<Item> DB::enumerateRemoved (uint64_t after)
	{
		std::vector<Item> result;

		auto cursor = m_conn->query (m_svcPrefix + "removed",
				QUERY ("seq" << mongo::GT << boost::lexical_cast<std::string> (after)));
		while (cursor->more ())
		{
			const auto& obj = cursor->next ();
			result.push_back ({ obj ["id"].String (), static_cast<uint64_t> (obj ["seq"].Long ()) });
		}

		return result;
	}

	uint64_t DB::getSeqNum (const std::string& id)
	{
		const auto& parentId = getParentId (id);
		if (!parentId)
			throw DBError ("cannot fetch sequence number: unknown parent id for " + id);

		auto cursor = m_conn->query (getNamespace (*parentId), QUERY ("id" << id));
		if (!cursor->more ())
			throw DBError ("cannot fetch sequence number: unknown item " + id);

		return cursor->next () ["seq"].Long ();
	}

	uint64_t DB::getSeqNum ()
	{
		auto idCursor = m_conn->query (m_svcPrefix + "state", QUERY ("id" << "lastSeq"));
		if (!idCursor->more ())
			return 0;

		return idCursor->next ().getIntField ("value");
	}

	uint64_t DB::incSeqNum (const std::string& id)
	{
		const auto& parentId = getParentId (id);
		if (!parentId)
			throw DBError ("cannot increment sequence number: unknown parent id for " + id);

		const auto newSeq = getSeqNum () + 1;
		m_conn->update (getNamespace (*parentId),
				QUERY ("id" << id),
				BSON ("seq" << static_cast<long long> (newSeq)));
		m_conn->update (m_svcPrefix + "state",
				QUERY ("id" << "lastSeq"),
				BSON ("value" << static_cast<long long> (newSeq)));

		setChildSeqNum (*parentId, newSeq);
		return newSeq;
	}

	uint64_t DB::addItem (Item item)
	{
		const auto& newSeq = getSeqNum () + 1;
		item.setSeq (newSeq);
		m_conn->insert (getNamespace (item.getParentId ()), toBSON (item));
		m_conn->insert (m_svcPrefix + "id2parent",
				BSON ("id" << item.getId ()
					<< "parentId" << item.getParentId ()));

		setChildSeqNum (item.getParentId (), newSeq);
		return newSeq;
	}

	uint64_t DB::modifyItem (const Item& item)
	{
		m_conn->update (getNamespace (item.getParentId ()),
				QUERY ("id" << item.getId ()),
				toBSON (item));
		const auto newSeq = incSeqNum (item.getId ());
		setChildSeqNum (item.getParentId (), newSeq);
		return newSeq;
	}

	uint64_t DB::removeItem (const std::string& id)
	{
		const auto& parent = getParentId (id);
		if (!parent)
			throw std::runtime_error ("unable to find parent item for " + id + " on removal");

		m_conn->remove (getNamespace (*parent),
				QUERY ("id" << id));
		const auto newSeq = getSeqNum () + 1;
		setChildSeqNum (*parent, newSeq);

		m_conn->remove (m_svcPrefix + "id2parent", QUERY ("id" << id));
		m_conn->insert (m_svcPrefix + "removed", BSON ("id" << id << "seq" << static_cast<long long> (newSeq)));

		return newSeq;
	}

	boost::optional<std::string> DB::getParentId (const std::string& id) const
	{
		auto idCursor = m_conn->query (m_svcPrefix + "id2parent", QUERY ("id" << id));
		if (!idCursor->more ())
			return {};

		return std::string (idCursor->next ().getStringField ("parentId"));
	}

	std::string DB::getNamespace (const std::string& parentId) const
	{
		return m_dbPrefix + (parentId.empty () ? parentId : "root");
	}

	void DB::drainParent (std::vector<Item>& result, uint64_t after, const std::string& parent) const
	{
		auto cursor = m_conn->query (getNamespace (parent),
				QUERY ("seq" << mongo::GT << boost::lexical_cast<std::string> (after) << "parent" << parent));
		while (cursor->more ())
		{
			const auto& obj = cursor->next ();
			const auto& id = obj ["id"].String ();
			result.push_back ({ id, static_cast<uint64_t> (obj ["seq"].Long ()) });

			drainParent (result, after, id);
		}
	}

	void DB::setChildSeqNum (const std::string& id, uint64_t newSeq)
	{
		if (id.empty ())
			return;

		auto parentId = getParentId (id);
		if (!parentId)
			throw std::runtime_error ("unable to increment seq counter");

		m_conn->update (getNamespace (*parentId),
				QUERY ("id" << id),
				BSON ("seq" << static_cast<long long> (newSeq)));
	}
}
